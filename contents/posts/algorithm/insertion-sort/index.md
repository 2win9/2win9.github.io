---
title: "정렬 중에 기본. 삽입 정렬"
description: "삽입 정렬은 트럼프 카드 정리!"
date: 2024-11-07
update: 2024-11-07
tags:
  - algorithm
  - sort
---

> 본 포스트는 저자가 학습하며 작성한 글입니다. 틀린 내용이 있다면 지적해주시면 감사하겠습니다!
## 1. 삽입정렬 (Insertion Sort)

![](./insertionsort.gif)

삽입정렬은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로 정렬을 수행하는 알고리즘이다.

이는 **트럼프 카드더미를 손 안에서 정리하는 방식**을 떠올리면 쉽게 이해할 수 있을 것이다.

1. 정렬되어 있지 않은 카드들을 받으면 가장 앞쪽부터 기준을 정한다.
2. 기준 카드를 오른손으로 빼고 그 앞에 있는 카드와 비교하여 더 작다면 뒤의 카드를 모두 한 칸씩 뒤로 밀어 놓고 그 카드의 앞에 끼워넣는다. (이 과정에서 가장 앞쪽이 기준인 경우는 정렬되어 있는 상태가 된다.)
3. 모든 카드가 기준이 될 때까지 반복한다.

## 2. 시간 복잡도

삽입 정렬은 정렬할 배열이 모두 **반대로** 정렬되어 있는 경우 최악의 성능을 보인다. 각 원소를 삽입할 때 이미 정렬된 부분의 모든 요소와 비교해야 하므로, 첫 번째 원소를 제외한 모든 원소를 **n - 1번**씩 비교하게 된다. 모든 기준을 순회하는 부분까지 고려하면 전체 시간복잡도는 $n*(n-1)$ 으로 계산된다.

즉, 삽입 정렬의 시간복잡도는  $O(n^2)$을 보장한다.


## 3. 구현

> 본 구현은 **오름차순**을 기준으로 한다.


```java
void insertionSort(int[] arr) {  
    for (int i = 0; i < arr.length; i++) // 배열의 모든 원소를 차례로 검사
    {  
        for (int j = 0; j < i; j++) // 현재 원소(arr[i])를 정렬된 부분(arr[0] ~ arr[i-1])과 비교
        {  
            if (arr[i] < arr[j]) // 현재 원소가 정렬된 부분의 어떤 원소(arr[j])보다 작으면
            {  
                int temp = arr[i]; // 현재 원소를 temp에 임시 저장
                
                for (int k = i; k > j; k--) // 뒤쪽 요소들을 한 칸씩 오른쪽으로 이동하여 자리 만들기
                    arr[k] = arr[k - 1];  
  
                arr[j] = temp; // 빈 자리에 temp를 삽입하여 정렬된 상태 유지
                break; // 현재 원소가 제자리에 들어갔으므로 더 이상 비교하지 않음
            }  
        }  
    }  
}  

```

먼저, 전체 배열의 원소 개수만큼 순회한다.
**제어변수 $i$ 는 현재 삽입할 요소의 기준 인덱스를 나타낸다.**

내부 반복문을 돌며  $arr[i]$ 보다 큰 $arr[j]$을 발견한다면 그 자리까지 모두 한칸씩 뒤로 이동시켜 자리를 만든다.

## 4. 정리

- 삽입정렬은 트럼프 카드 정리와 같은 방식의 정렬 알고리즘
- 모든 카드가 반대로 정렬되어 있다면 원소 삽입 시 비교해야 한다.
- 따라서 $O(N^2)$ 의 시간복잡도를 갖음

## 5. 참고

- [위키백과 - 삽입 정렬
  ](https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC)